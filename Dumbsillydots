import random
import math
import pygame

#import random: This library is used for generating random numbers. It's crucial for initializing random movement directions (random_angle) in the Brain class and for mutations.
#import math: Provides mathematical functions needed for calculations like square root (math.sqrt), trigonometric functions (math.cos, math.sin), and distance calculation (math.hypot).
#import pygame: Pygame is a set of Python modules designed for writing video games and graphical applications. It provides functions for drawing shapes, handling events, and managing graphical resources.
 
#Imports: These lines import necessary libraries:
#random: Provides functions for generating random numbers.
#math: Provides mathematical functions, like sqrt and cos.
#pygame: A library used for creating games and graphical applications.


 
class PVector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
#PVector Class: Represents a 2D vector (similar to a point in 2D space).
#__init__: Initializes the vector with x and y coordinates.
#add: Adds another vector vec to the current vector.
#limit: Limits the magnitude of the vector to max_val.
#copy: Creates and returns a copy of the vector.
#from_angle: Static method that creates a vector from an angle (using trigonometric functions).        

    def add(self, vec):
        self.x += vec.x
        self.y += vec.y

#Purpose: PVector represents a 2D vector (or point) with methods for vector operations.
#Attributes (__init__): Initializes a vector with x and y coordinates.
#add Method: Adds another vector (vec) to the current vector (self).
#limit Method: Restricts the magnitude of the vector to max_val. If the magnitude exceeds max_val, scales down the vector to the specified length while maintaining its direction.
#copy Method: Creates and returns a new PVector instance with the same coordinates (x and y). This method is crucial for creating copies of vectors, useful for operations that require preserving the original state of vectors.
    def limit(self, max_val):
        magnitude = math.sqrt(self.x**2 + self.y**2)
        if magnitude > max_val:
            self.x = (self.x / magnitude) * max_val
            self.y = (self.y / magnitude) * max_val
#from_angle Method (Static): Creates a PVector instance from an angle (angle in radians). It uses trigonometric functions (math.cos and math.sin) to calculate the x and y components of the vector based on the angle. This is particularly useful for generating random movement directions in the Brain class and other scenarios where direction based on angle is needed.            

    def copy(self):
        return PVector(self.x, self.y)

    @staticmethod
    def from_angle(angle):
        return PVector(math.cos(angle), math.sin(angle))

def dist(v1, v2):
    return math.hypot(v1.x - v2.x, v1.y - v2.y)
#dist Function: Calculates the Euclidean distance between two vectors v1 and v2.
#Uses math.hypot to calculate the distance between two points defined by their x and y coordinates (v1.x - v2.x and v1.y - v2.y). This function is essential for determining if a dot has reached its goal (self.goal) in the Dot class.

class Brain:
    def __init__(self, size):
        self.directions = [PVector(0, 0) for _ in range(size)]
        self.step = 0
        self.randomize()
    
    def randomize(self):
        for i in range(len(self.directions)):
            random_angle = random.uniform(0, 2 * math.pi)
            self.directions[i] = PVector.from_angle(random_angle)

    def clone(self):
        clone = Brain(len(self.directions))
        for i in range(len(self.directions)):
            clone.directions[i] = self.directions[i].copy()
        return clone

    def mutate(self):
        mutation_rate = 0.01
        for i in range(len(self.directions)):
            rand = random.uniform(0, 1)
            if rand < mutation_rate:
                random_angle = random.uniform(0, 2 * math.pi)
                self.directions[i] = PVector.from_angle(random_angle)


 
 
#Purpose: Brain manages a set of movement directions (directions) for a dot (Dot class).
#directions: List of PVector objects representing movement directions, initialized with zero vectors (PVector(0, 0)).
#step: Tracks the current step or direction index.
#randomize Method: Initializes directions with random movement directions using PVector.from_angle. Each direction is generated by choosing a random angle between 0 and 2 * math.pi (full circle).
#clone Method: Creates a deep copy (clone) of the Brain instance. This is useful for creating new instances (dots) with identical movement strategies, preserving the genetic information through generations.
#mutate Method: Introduces mutations in the movement directions (directions) based on a mutation rate (mutation_rate).
#It iterates through each direction and decides whether to apply a mutation based on a randomly generated value (rand).
#If rand is less than mutation_rate, the direction is randomly changed by generating a new random angle (random_angle) using PVector.from_angle.

class Dot:
    def __init__(self, width, height, goal):
        self.pos = PVector(width / 2, height - 10)
        self.vel = PVector(0, 0)
        self.acc = PVector(0, 0)
        self.brain = Brain(1000)
        self.dead = False
        self.reached_goal = False
        self.is_best = False
        self.fitness = 0
        self.width = width
        self.height = height
        self.goal = goal

    def show(self, screen):
        if self.is_best:
            color = (0, 255, 0)
            size = 8
        else:
            color = (0, 0, 0)
            size = 4
        pygame.draw.circle(screen, color, (int(self.pos.x), int(self.pos.y)), size)

    def move(self):
        if self.brain.step < len(self.brain.directions):
            self.acc = self.brain.directions[self.brain.step]
            self.brain.step += 1
        else:
            self.dead = True

        self.vel.add(self.acc)
        self.vel.limit(5)
        self.pos.add(self.vel)
        
#update Method: Updates the dot's state based on its movement and goal-reaching status:

#Checks if the dot is neither dead nor reached_goal.
#Calls move to update its position based on its brain's directions and velocity.
#Checks boundary conditions to determine if the dot has moved out of the screen (self.pos.x < 2, self.pos.y < 2, etc.). If true, sets self.dead to True.
#Uses the dist function to check if the dot has reached the goal (dist(self.pos, self.goal) < 5). If true, sets self.reached_goal to True.

    def update(self):
        if not self.dead and not self.reached_goal:
            self.move()
            if self.pos.x < 2 or self.pos.y < 2 or self.pos.x > self.width - 2 or self.pos.y > self.height - 2:
                self.dead = True
            elif dist(self.pos, self.goal) < 5:
                self.reached_goal = True

    def calculate_fitness(self):
        if self.reached_goal:
            self.fitness = 1.0 / 16.0 + 10000.0 / (self.brain.step * self.brain.step)
        else:
            distance_to_goal = dist(self.pos, self.goal)
            self.fitness = 1.0 / (distance_to_goal * distance_to_goal)

    def gimme_baby(self):
        baby = Dot(self.width, self.height, self.goal)
        baby.brain = self.brain.clone()
        return baby

 

class Population:
    def __init__(self, size, width, height, goal):
        self.dots = [Dot(width, height, goal) for _ in range(size)]
        self.fitness_sum = 0
        self.gen = 1
        self.best_dot = 0
        self.min_step = 1000

    def show(self, screen):
        for dot in self.dots:
            dot.show(screen)

    def update(self):
        for dot in self.dots:
            if dot.brain.step > self.min_step:
                dot.dead = True
            else:
                dot.update()

    def calculate_fitness(self):
        for dot in self.dots:
            dot.calculate_fitness()

    def all_dots_dead(self):
        return all(dot.dead or dot.reached_goal for dot in self.dots)

    def natural_selection(self):
        new_dots = [None] * len(self.dots)
        self.set_best_dot()
        self.calculate_fitness_sum()

        new_dots[0] = self.dots[self.best_dot].gimme_baby()
        new_dots[0].is_best = True
        for i in range(1, len(new_dots)):
            parent = self.select_parent()
            new_dots[i] = parent.gimme_baby()

        self.dots = new_dots
        self.gen += 1

    def calculate_fitness_sum(self):
        self.fitness_sum = sum(dot.fitness for dot in self.dots)

    def select_parent(self):
        rand = random.uniform(0, self.fitness_sum)
        running_sum = 0
        for dot in self.dots:
            running_sum += dot.fitness
            if running_sum > rand:
                return dot
        return None

    def mutate_dem_babies(self):
        for i in range(1, len(self.dots)):
            self.dots[i].brain.mutate()

    def set_best_dot(self):
        max_fitness = max(dot.fitness for dot in self.dots)
        for i, dot in enumerate(self.dots):
            if dot.fitness == max_fitness:
                self.best_dot = i
                break

        if self.dots[self.best_dot].reached_goal:
            self.min_step = self.dots[self.best_dot].brain.step
            print(f"Step: {self.min_step}")

 

class PVector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def add(self, vec):
        self.x += vec.x
        self.y += vec.y

    def limit(self, max_val):
        magnitude = math.sqrt(self.x**2 + self.y**2)
        if magnitude > max_val:
            self.x = (self.x / magnitude) * max_val
            self.y = (self.y / magnitude) * max_val

    def copy(self):
        return PVector(self.x, self.y)

    @staticmethod
    def from_angle(angle):
        return PVector(math.cos(angle), math.sin(angle))

def dist(v1, v2):
    return math.hypot(v1.x - v2.x, v1.y - v2.y)

 

# Constants
WIDTH, HEIGHT = 800, 800
FPS = 200
POP_SIZE = 1000
GOAL = PVector(400, 10)

# Setup Pygame
pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
clock = pygame.time.Clock()

population = Population(POP_SIZE, WIDTH, HEIGHT, GOAL)

# Main loop
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.fill((255, 255, 255))

    # Draw goal
    pygame.draw.circle(screen, (255, 0, 0), (int(GOAL.x), (int(GOAL.y))), 10)

    if population.all_dots_dead():
        population.calculate_fitness()
        population.natural_selection()
        population.mutate_dem_babies()
    else:
        population.update()
        population.show(screen)

    pygame.display.flip()
    clock.tick(FPS)

pygame.quit()

